#!/usr/bin/python3

'''
Python 类型注解（Type Hints）
想象一下，你给朋友寄一个包裹。如果你在包裹上写明"易碎品"和"向上箭头"，快递员就会知道要小心轻放、正确朝向。类型注解（Type Hints） 在编程中就扮演着类似的角色——它是一种为代码添加"说明标签"的技术，明确地指出变量、函数参数和返回值应该是什么数据类型。

简单来说，类型注解就是在代码中注明数据类型的语法，它的核心目的是：

提高代码可读性：让他人（以及未来的你）一眼就能看懂代码的意图
便于静态检查：在运行代码前，通过工具发现潜在的类型错误
增强IDE支持：让代码编辑器提供更准确的自动补全和提示
一个简单的例子：

实例
# 没有类型注解
def greet(name):
    return f"Hello, {name}"

# 有类型注解
def greet(name: str) -> str:
    return f"Hello, {name}"
第二段代码明确指出了 name 应该是字符串类型（str），函数会返回一个字符串（-> str）。

为什么需要类型注解？
Python 以其动态类型特性而闻名——你不需要提前声明变量的类型，解释器会在运行时自动推断。这虽然灵活，但也带来了问题：

代码难以理解：看到一个函数时，不清楚应该传入什么类型的数据
隐藏的bug：可能不小心传入了错误类型，直到运行时才报错
开发效率低：IDE无法提供准确的代码提示和补全
类型注解通过提供可选的类型信息来解决这些问题，让你的代码更加健壮和可维护。

基础语法详解
变量注解
从 Python 3.6 开始，你可以直接为变量添加类型注解：

实例
# 没有类型注解的代码
name = "Alice"
age = 30
is_student = False
scores = [95, 88, 91]

# 有类型注解的代码
name: str = "Alice"       # 注解为字符串 (str)
age: int = 30             # 注解为整数 (int)
is_student: bool = False  # 注解为布尔值 (bool)
scores: list = [95, 88, 91] # 注解为列表 (list)
说明：name: str 读作"变量 name 的类型是 str"。

函数注解
在函数参数后加 : 类型。

实例
# 没有类型注解的函数
def greet(first_name, last_name):
    full_name = first_name + " " + last_name
    return "Hello, " + full_name

# 有类型注解的函数
def greet(first_name: str, last_name: str) -> str:
    full_name = first_name + " " + last_name
    return "Hello, " + full_name
解读这个函数：

first_name: str：参数 first_name 应该是字符串。
last_name: str：参数 last_name 应该是字符串。
-> str：这个函数执行后会返回一个字符串。
现在，任何人调用这个函数时，都能清晰地知道需要传递什么，以及会得到什么。

函数注解是类型注解最常见的应用场景：

实例
def add_numbers(a: int, b: int) -> int:
    """将两个整数相加并返回结果"""
    return a + b

# 调用函数
result = add_numbers(5, 3)  # 正确：两个整数
# result = add_numbers("5", "3")  # 可能有问题：虽然能运行，但类型检查器会警告
参数默认值
你可以同时使用类型注解和默认值：

实例
def say_hello(name: str, times: int = 1) -> str:
    """向某人问好指定次数"""
    return " ".join([f"Hello, {name}!"] * times)

print(say_hello("Bob"))      # 输出：Hello, Bob!
print(say_hello("Alice", 3)) # 输出：Hello, Alice! Hello, Alice! Hello, Alice!
复杂类型注解
基本的 str, int, list 很好用，但如果我们想表达"一个由整数组成的列表"该怎么办？这时就需要 Python 的 typing 模块提供更强大的工具。

列表、字典等容器类型
实例
from typing import List, Dict, Tuple, Set

# List[int] 表示这是一个只包含整数的列表
numbers: List[int] = [1, 2, 3, 4, 5]

# Dict[str, int] 表示这是一个键为字符串、值为整数的字典
student_scores: Dict[str, int] = {"Alice": 95, "Bob": 88}

# Tuple[int, str, bool] 表示这是一个包含整数、字符串、布尔值的元组
person_info: Tuple[int, str, bool] = (25, "Alice", True)

# Set[str] 表示这是一个只包含字符串的集合
unique_names: Set[str] = {"Alice", "Bob", "Charlie"}
可选类型（Optional）
当值可能是某种类型或者是 None 时使用：

实例
from typing import Optional

def find_student(name: str) -> Optional[str]:
    """根据名字查找学生，可能找到也可能返回None"""
    students = {"Alice": "A001", "Bob": "B002"}
    return students.get(name)  # 可能返回字符串或None

# 等价于 Union[str, None]
联合类型（Union）
当值可能是多种类型之一时使用：

实例
from typing import Union

def process_input(data: Union[str, int, List[int]]) -> None:
    """处理可能是字符串、整数或整数列表的输入"""
    if isinstance(data, str):
        print(f"字符串: {data}")
    elif isinstance(data, int):
        print(f"整数: {data}")
    elif isinstance(data, list):
        print(f"列表: {data}")

process_input("hello")    # 输出：字符串: hello
process_input(42)         # 输出：整数: 42  
process_input([1, 2, 3])  # 输出：列表: [1, 2, 3]
类型检查实战
使用 Mypy 进行静态类型检查
Mypy 是最流行的 Python 类型检查器。首先安装它：

pip install mypy
假设我们有一个有潜在类型问题的文件 example.py：

实例
# example.py
def add_numbers(a: int, b: int) -> int:
    return a + b

result = add_numbers("5", "3")  # 这里有问题！传入了字符串
运行 mypy 检查：

mypy example.py
你会看到类似这样的输出：

example.py:4: error: Argument 1 to "add_numbers" has incompatible type "str"; expected "int"
example.py:4: error: Argument 2 to "add_numbers" has incompatible type "str"; expected "int"
Found 2 errors in 1 file (checked 1 source file)
在 IDE 中实时检查
现代 IDE（如 VS Code、PyCharm）都内置了类型检查支持：

错误高亮：类型不匹配的代码会被标记出来
智能提示：输入代码时会显示参数和返回值的类型信息
自动补全：基于类型信息提供更准确的代码补全建议
最佳实践指南
1. 渐进式采用
从新代码开始使用类型注解
逐步为重要的旧代码添加注解
不需要一次性为所有代码添加类型
2. 保持一致性
在项目中保持统一的注解风格
团队协商决定注解的详细程度
3. 避免过度注解
实例
# 不推荐：过于明显的类型不需要注解
x: int = 5  # 5明显是整数，可以省略注解

# 推荐：为复杂逻辑或公共接口添加注解
def calculate_statistics(data: List[float]) -> Dict[str, float]:
    """计算数据的各种统计指标"""
    # 复杂实现...
4. 处理第三方库
对于没有类型注解的第三方库，可以：

查看是否有对应的类型存根文件（通常叫 types-packageName）
使用 Any 类型暂时绕过检查
或者为常用函数添加自己的类型注解
常见问题解答
类型注解会影响性能吗？
不会。类型注解在运行时会被忽略，只用于静态分析和开发工具。

必须使用类型注解吗？
不强制。Python 仍然是动态类型语言，类型注解是可选的。但强烈推荐使用，特别是大型项目。

如果注解错了会怎么样？
类型检查器会报错，但程序仍然可以运行。注解只是"提示"而不是"强制"。

总结与实践
类型注解是提升代码质量的强大工具。让我们通过一个综合练习来巩固所学：

实例
from typing import List, Dict, Optional, Union

def process_students(students: List[Dict[str, Union[str, int]]]) -> Optional[float]:
    """
    处理学生数据，计算平均分数
   
    参数:
        students: 学生列表，每个学生是包含'name'和'score'的字典
       
    返回:
        平均分数（浮点数），如果没有学生则返回None
    """
    if not students:
        return None
   
    total = 0
    for student in students:
        total += student['score']
   
    return total / len(students)

# 测试数据
students_data = [
    {"name": "Alice", "score": 95},
    {"name": "Bob", "score": 88},
    {"name": "Charlie", "score": 92}
]

average = process_students(students_data)
print(f"平均分: {average}")
输出结果为：

平均分: 91.66666666666667
'''
# 类型注解是提升代码质量的强大工具。让我们通过一个综合练习来巩固所学：
from typing import List,Dict,Optional,Union

def process_students(students:List[Dict[str,Union[str,int]]])->Optional[float]:
    '''
    处理学生数据，计算平均分
    参数：
        students：学生列表，每个学生是包含'name' 'score'的字典
    返回：
        平均分数（浮点数）。如果没有学生则返回None
    '''
    if not students:
        return None
    
    total = 0
    for stu in students:
        total += stu['score']
    return total/len(students)

# 测试数据
students_data = [
    {"name": "Alice", "score": 95},
    {"name": "Bob", "score": 88},
    {"name": "Charlie", "score": 92}
]
avg = process_students(students_data)
print('平均分：',avg) # 平均分： 91.66666666666667

# 没有类型注解
def greet(name):
    return f"hello,{name}"

name = "Alice"
age = 30
is_student = False
scores = [99,88,91]

# 有类型注解
def greet(name:str) ->str: # 注解参数name 为字符串类型，返回值 为字符串类型
    return f"hello,{name}"

name:str = "Alice" # 注解为字符串
age:int = 30 # 注解为整数
is_student:bool = False # 注解为布尔值
scores:list = [99,88,91] # 注解为列表